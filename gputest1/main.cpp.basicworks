//
//  main.cpp
//  gputest1
//
//  Created by Chris Nicholas on 07/09/2016.
//  Copyright Â© 2016 Chris Nicholas. All rights reserved.
//

#include <stdio.h>

//#define PROGRAM_FILE "simplekern.cl"
#define __CL_ENABLE_EXCEPTIONS

#include <iostream>
#include <fstream>
#include <iterator>
#ifdef __APPLE__
#include <OpenCL/opencl.h>
#include <OpenCL/cl.hpp>
#else
#include <CL/cl.h>
#include <CL/cl.hpp>
#endif
//#include <OpenCL/opencl.h>

#include <time.h>
#include <cmath>
//#include <position.h>
#include "gdal_priv.h"
#include <Utils.h>
//#include <worldParams.h>
//#include <motionUtils.h>
#include <iomanip>
//#include <recShot.h>

#define __CL_ENABLE_EXCEPTIONS

#include <vector>
#include <cstdio>
#include <cstdlib>
#include <string>

#include <iostream>
#include <fstream>

// pick up device type from compiler command line or from the default type
#ifndef DEVICE
#define DEVICE CL_DEVICE_TYPE_DEFAULT
#endif

//------------------------------------------------------------------------------

#define TOL    (0.001)   // tolerance used in floating point comparisons
#define LENGTH (1024)    // length of vectors a, b, and c

int main(void)
{
    char* kernelsSrc = "/Users/dusted-dstl/Documents/xcodeworkspace/gpublos/gputest1/simplekern.cl";
    
    //std::vector<float> h_input(LENGTH);                // input vector
    float *h_input = new float[LENGTH];
    //std::vector<float> h_output(LENGTH);   // output vector (result)
    float *h_output = new float[LENGTH];
    
    // Fill vectors a and b with random float values
    int count = LENGTH;
    for(int i = 0; i < count; i++)
    {
        h_input[i]  = 0.1f;
        h_output[i] = 0.0f;
    }
    
    std::cout << "Size of input arr: "  << sizeof(h_input) << std::endl;
    std::cout << "An example from it "  << h_input[5] << std::endl;
    
    try
    {
        
        // For catching cl errors
        cl_int err;
        //get all platforms (drivers)
        std::vector<cl::Platform> platforms;
        std::vector<cl::Device> devices;
        std::vector<cl::Kernel> kernels;
        cl::Platform::get(&platforms);
        if(platforms.size()==0){
            std::cout<<" No platforms found. Check OpenCL installation!\n";
            exit(1);
        }
        std::cout << " All Platforms follow " << std::endl;
        for (auto plat : platforms) {
            std::cout << plat.getInfo<CL_PLATFORM_NAME>() << std::endl;
        }
        cl::Platform default_platform=platforms[0];
        std::cout << "Querying platform: "<<default_platform.getInfo<CL_PLATFORM_NAME>()<<"\n";
        
        //get default device of the default platform
        default_platform.getDevices(CL_DEVICE_TYPE_ALL, &devices);
        if(devices.size()==0){
            std::cout<<" No devices found. Check OpenCL installation!\n";
            exit(1);
        }
        std::cout << " All Devices follow " << std::endl;
        for (auto dev : devices) {
            std::cout << dev.getInfo<CL_DEVICE_NAME>() << std::endl;
        }
        
        
        // create platform
        cl::Platform::get(&platforms);
        //CPU Implementation
        platforms[0].getDevices(CL_DEVICE_TYPE_CPU, &devices);
        //GPU Implementation
        //platforms[0].getDevices(CL_DEVICE_TYPE_GPU, &devices);
        //Query device info for memory size
        std::cout << devices[0].getInfo<CL_DEVICE_LOCAL_MEM_SIZE>() << std::endl;
        
        //Change this if want to use GPU
        cl::Context context = cl::Context(devices);
        
        //Create Command queue
        cl::CommandQueue queue(context, devices[0]);
        
        // load opencl source
        std::ifstream cl_file(kernelsSrc);
        std::string cl_string(std::istreambuf_iterator<char>(cl_file), (std::istreambuf_iterator<char>()));
        cl::Program::Sources source(1, std::make_pair(cl_string.c_str(), cl_string.length()+1));
        
        // create program
        cl::Program program(context, source);
        
        try {
            
            // compile opencl source
            program.build(devices);
            std::cout << "built program" << std::endl;
            
        }
        catch (cl::Error &err) {
            //Get the build log for the first device
            std::cerr << "Building failed, " << err.what() << "(" << err.err() << ")"
            << "\nRetrieving build log\n"
            << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0])
            << "\n";
            return -1;
            
        }
        try {
        
            //Make buffers for mem transfer - input
            cl::Buffer d_input = cl::Buffer(context, CL_MEM_READ_WRITE, LENGTH*sizeof(float), NULL, &err);
            //Output - just say where device writes it
            cl::Buffer d_output = cl::Buffer(context, CL_MEM_READ_WRITE , LENGTH*sizeof(float), NULL, &err);
            
            //WRite Buffers to device
            queue.enqueueWriteBuffer(d_input,CL_TRUE,0,LENGTH*sizeof(float), h_input);
            
            cl::KernelFunctor testBasic(cl::Kernel(program,"testBasic"),queue,cl::NullRange,cl::NDRange(LENGTH),cl::NullRange);
            //for (int i=0; i<5; i++){
            testBasic(d_input, d_output);
            
            //cl::Kernel testBasic_k(program, "testBasic");
            
            //testBasic_k.setArg(0, d_input);
            //testBasic_k.setArg(1, d_output);
            
            //Copy Data out
            //cl::NDRange global(LENGTH);
            //cl::NDRange local(1);
            //queue.enqueueNDRangeKernel(testBasic_k, cl::NullRange, global, local);
            
            err = queue.enqueueReadBuffer(d_output, CL_TRUE, 0, LENGTH*sizeof(float), h_output, NULL, NULL);
        
            std::cout << "Done" << std::endl;
            
        }
        catch (cl::Error &err) {
            //Get the build log for the first device
            std::cerr << "Building failed, " << err.what() << "(" << err.err() << ")"
            << "\nRetrieving build log\n"
            << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0])
            << "\n";
            return -1;
            
        }

        
    }
    catch (cl::Error err) {
        std::cout << "Exception\n";
        std::cerr
        << "ERROR: "
        << err.what()
        << "("
        << ")"
        << std::endl;
    }
}