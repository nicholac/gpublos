//
//  main.cpp
//  gputest1
//
//  Created by Chris Nicholas on 26/05/2015.
//  Copyright (c) 2015 Chris Nicholas. All rights reserved.
//

//#define PROGRAM_FILE "simplekern.cl"
#define __CL_ENABLE_EXCEPTIONS

#include <iostream>
#include <fstream>
#include <iterator>
#ifdef __APPLE__
#include <OpenCL/opencl.h>
#include <cl.hpp>
#else
#include <CL/cl.h>
#include <CL/cl.hpp>
#endif
//#include <OpenCL/opencl.h>

#include <time.h>
#include <cmath>
//#include <position.h>
#include "gdal_priv.h"
#include <Utils.h>
//#include <worldParams.h>
//#include <motionUtils.h>
#include <iomanip>
//#include <recShot.h>


int main(int argc, const char * argv[]) {
    
    //Files, vars etc
    char* demFName = "/Users/dusted-ipro/geodata/mount.dem";
    char* intersectKernel = "/Users/dusted-ipro/Documents/code/code/xcode/gputest1/gputest1/simplekern.cl";
    float tgtX = 562721.0;
    float tgtY = 5117017.0;
    double tgtPxX = 0.0;
    double tgtPxY = 0.0;
    int skipVal = 1000;
    float minDist = 600.0;
    float maxDist = 4500.0;
    float gravity = 9.82;
    //TODO: Alter this based on the altitude
    float airDens = 1.225;
    //TODO: Allow setting of this based on weapon vars
    //Using Sreamlined body coefficient
    float dragCoef = 0.04; //Coef for sphere
    float pi = 3.1415926; // pi
    float calibre = 0.081;
    float fArea = pi*(pow((0.5*calibre), 2.0));
    float mortSigma = dragCoef*fArea*0.5*airDens;
    float muzzVel = 225.0;
    float mortMass = 4.2;
    float gForce = mortMass * gravity;
    //float launchZ = 0.0;
    float tgtZ = 0.0;
    char* fName = "/Users/dusted-ipro/geodata/gpu_out1.csv";
    
    
    
    // For catching cl errors
    cl_int err;
    //get all platforms (drivers)
    std::vector<cl::Platform> platforms;
    std::vector<cl::Device> devices;
    std::vector<cl::Kernel> kernels;
    cl::Platform::get(&platforms);
    if(platforms.size()==0){
        std::cout<<" No platforms found. Check OpenCL installation!\n";
        exit(1);
    }
    std::cout << " All Platforms follow " << std::endl;
    for (auto plat : platforms) {
        std::cout << plat.getInfo<CL_PLATFORM_NAME>() << std::endl;
    }
    cl::Platform default_platform=platforms[0];
    std::cout << "Querying platform: "<<default_platform.getInfo<CL_PLATFORM_NAME>()<<"\n";
    
    //get default device of the default platform
    default_platform.getDevices(CL_DEVICE_TYPE_ALL, &devices);
    if(devices.size()==0){
        std::cout<<" No devices found. Check OpenCL installation!\n";
        exit(1);
    }
    std::cout << " All Devices follow " << std::endl;
    for (auto dev : devices) {
        std::cout << dev.getInfo<CL_DEVICE_NAME>() << std::endl;
    }
    
    
    // create platform
    cl::Platform::get(&platforms);
    platforms[0].getDevices(CL_DEVICE_TYPE_CPU, &devices);
    //Query device info for memory size
    std::cout << devices[0].getInfo<CL_DEVICE_LOCAL_MEM_SIZE>() << std::endl;
    
    //Change this if want to use GPU
    cl::Context context = cl::Context(devices);
    
    //Create Command queue
    cl::CommandQueue queue(context, devices[0]);
    
    // load opencl source
    std::ifstream cl_file(intersectKernel);
    std::string cl_string(std::istreambuf_iterator<char>(cl_file), (std::istreambuf_iterator<char>()));
    cl::Program::Sources source(1, std::make_pair(cl_string.c_str(), cl_string.length()+1));
    
    // create program
    cl::Program program(context, source);
    
    try {
        
        // compile opencl source
        program.build(devices);
        std::cout << "built kernel" << std::endl;
        
    }
    catch (cl::Error &err) {
        //Get the build log for the first device
        std::cerr << "Building failed, " << err.what() << "(" << err.err() << ")"
        << "\nRetrieving build log\n"
        << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0])
        << "\n";
        return -1;
        
    }
    
    std::cout << "Loading Kern func" << std::endl;
    // load named kernel from opencl source
    cl::Kernel kernel(program, "gdal_intersect");
    
    std::cout << "Building indata" << std::endl;
    
    //Open the DEM and load data into memory
    //GDAL Vars
    double        adfGeoTransform[6];
    //float rasterXSize = 0.0;
    //float rasterYSize = 0.0;
    GDALDataset  *poDataset;
    poDataset = Utils::openDem(demFName);
    
    //Get geotransform info ready
    poDataset->GetGeoTransform( adfGeoTransform );
    float gt0 = float(adfGeoTransform[0]);
    float gt1 = float(adfGeoTransform[1]);
    float gt2 = float(adfGeoTransform[2]);
    float gt3 = float(adfGeoTransform[3]);
    float gt4 = float(adfGeoTransform[4]);
    float gt5 = float(adfGeoTransform[5]);
    std::cout << gt0 << " // " << adfGeoTransform[0] << std::endl;
    int rasterXSize = poDataset->GetRasterXSize();
    int rasterYSize = poDataset->GetRasterYSize();
    int taskSize = rasterXSize*rasterYSize;
    std::cout << "rasterSizeX: " << rasterXSize << std::endl;
    std::cout << "rasterSizeY: " << rasterYSize << std::endl;
    
    GDALRasterBand  *poBand;
    poBand = poDataset->GetRasterBand( 1 );
    int   nXSize = poBand->GetXSize();
    int   nYSize = poBand->GetYSize();
    
    std::vector<float> demSP = Utils::GDAL2VEC (poDataset);
    GDALClose( (GDALDatasetH) poDataset );
    std::cout << "Size of DEM in memory Ref (kb): " << (taskSize*sizeof(float))/1000 << std::endl;
    std::cout << "Size of DEM: " << demSP.size() << " tasksize: " << taskSize << std::endl;
    //Get the tgtz ready
    Utils::coordtoPx2d(tgtX, tgtY, tgtPxX, tgtPxY, adfGeoTransform, rasterXSize, rasterYSize);
    tgtZ = demSP.at(tgtPxY*rasterXSize+tgtPxX);
    
    clock_t tt = clock();
    
    try {
        //THESE TWO FOR CPU - then COMMENT CPU
        //Create a buffer object to this memory
        cl::Buffer inBuffDEMFull(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, taskSize*sizeof(float), &demSP, &err);
        int outArr[taskSize];
        
        
        //THESE TWO FOR GPU
        //std::vector<int> h_outArr = std::vector<int>(taskSize);
        //cl::Buffer inBuffDEMFull(context, demSP.begin(), demSP.end(),true);
        
        //THIS FOR CPU AND GPU
        cl::Buffer outBuff(context, CL_MEM_WRITE_ONLY, taskSize*sizeof(cl_int), NULL, NULL);
        
        //Set Kernel Args
        err = kernel.setArg(0, inBuffDEMFull);
        err = kernel.setArg(1, sizeof(float), &tgtX);
        err = kernel.setArg(2, sizeof(float), &tgtY);
        err = kernel.setArg(3, sizeof(int), &rasterXSize);
        err = kernel.setArg(4, sizeof(int), &rasterYSize);
        err = kernel.setArg(5, sizeof(float), &gt0);
        err = kernel.setArg(6, sizeof(float), &gt1);
        err = kernel.setArg(7, sizeof(float), &gt2);
        err = kernel.setArg(8, sizeof(float), &gt3);
        err = kernel.setArg(9, sizeof(float), &gt4);
        err = kernel.setArg(10, sizeof(float), &gt5);
        err = kernel.setArg(11, sizeof(float), &minDist);
        err = kernel.setArg(12, sizeof(float), &maxDist);
        err = kernel.setArg(13, sizeof(float), &mortMass);
        err = kernel.setArg(14, sizeof(float), &muzzVel);
        err = kernel.setArg(15, sizeof(float), &mortSigma);
        err = kernel.setArg(16, sizeof(float), &gForce);
        err = kernel.setArg(17, sizeof(float), &tgtZ);
        //err = kernel.setArg(16, sizeof(double), &maxDist);
        //err = kernel.setArg(5, sizeof(double)*6, &adfGeoTransform);
        err = kernel.setArg(18, outBuff);
        if(err < 0) {
            perror("Couldn't create a kernel argument");
            exit(1);
        }
        // execute kernel
        //just does 1 dim - queue.enqueueTask(kernel);
        queue.enqueueNDRangeKernel(kernel, 0, taskSize);
        
        //Write the outputs
        //THIS FOR GPU - then comment next
        //cl::copy(queue, outBuff, h_outArr.begin(), h_outArr.end());
        
        //THIS FOR CPU - COMMENT PREVIOUS
        queue.enqueueReadBuffer(outBuff, true, 0, taskSize*sizeof(cl_int), outArr);

        //int * output = (int *) queue.enqueueMapBuffer(outBuff, CL_TRUE, CL_MAP_READ, 0, taskSize * sizeof(int));
        //err = queue.enqueueUnmapMemObject(outBuff,(void *) output);
        
        // wait for completion
        queue.finish();
        
        tt = clock() - tt;
        std::cout << "Done CL Proc: " << float(tt)/CLOCKS_PER_SEC << std::endl;
        
        //THIS FOR GPU
//        int tst = 0;
//        for (int i; i<taskSize; i++){
//            if (h_outArr.at(i) > tst){
//                tst=h_outArr.at(i);
//                std::cout << "Max Val Out: " << tst << std::endl;
//            }
//        }
        
        //THIS FOR CPU
        int tst = 0;
        for (int i; i<taskSize; i++){
            if (outArr[i] > tst){
                tst=outArr[i];
                std::cout << "Max Val Out: " << tst << std::endl;
            }
        }
        
        //Find Maximum in outputs - checking
        //int tst = 0;
        //for (int i; i<taskSize; i++){
        //    if (outArr[i] > tst){
        //        tst=outArr[i];
        //        std::cout << "Max Val Out: " << tst << std::endl;
        //    }
        //}
        //std::cout << "Max Val Out: " << tst << std::endl;
        /*
        //Drop the output to a textfile
        std::ofstream output(fName);
        if (!output) { // check the file opened OK
            std::cerr << "error: open file for output failed!" << std::endl;
            return 1;
        }
        //Headers
        output << "Position X" << "," << "Position Y" << "," << "pixelX" << "," << "pixelY" << "," << "result" << std::endl;
        //Sizes should all be same
        for (unsigned int i=0; i<taskSize; i++){
            float pxX, pxY;
            //Work out pixel location adn launch from 1d index
            float tmp = std::modf(float(i)/rasterXSize, &pxY);
            float tmp2 = std::modf(tmp * rasterXSize, &pxX);
            //std::cout << gt0 << " // " << gt1 << " // " << gt2 << std::endl;
            float X = gt0+(pxX*gt1)+pxY*gt2;
            float Y = gt3+(pxX*gt4)+pxY*gt5;
            // the ofstream object replaces std::cout here, then its the same use
            output << std::setprecision(10) << X << "," << Y << "," << pxX << "," << pxY << "," << h_outArr[i] << std::endl;
        }
        output.close();
         */
        
        
    }
    catch (cl::Error &err) {
        //Get the build log for the first device
        std::cerr << "Building failed, " << err.what() << "(" << err.err() << ")"
        << "\nRetrieving build log\n"
        << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0])
        << "\n";
        return -1;
    }
    
    
    std::cout << "Done" << std::endl;
    
    return 0;
}









