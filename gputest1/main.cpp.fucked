//
//  main.cpp
//  gputest1
//
//  Created by Chris Nicholas on 26/05/2015.
//  Copyright (c) 2015 Chris Nicholas. All rights reserved.
//

//#define PROGRAM_FILE "simplekern.cl"
#define __CL_ENABLE_EXCEPTIONS

#include <iostream>
#include <fstream>
#include <iterator>
#ifdef __APPLE__
#include <OpenCL/opencl.h>
#include <OpenCL/cl.hpp>
#else
#include <CL/cl.h>
#include <CL/cl.hpp>
#endif
//#include <OpenCL/opencl.h>

#include <time.h>
#include <cmath>
#include <position.h>
#include "gdal_priv.h"
#include <Utils.h>
#include <worldParams.h>
#include <motionUtils.h>
//#include <recShot.h>


int main(int argc, const char * argv[]) {
    
    //Files, vars etc
    char* demFName = "/Users/dusted-ipro/geodata/mount.dem";
    char* intersectKernel = "/Users/dusted-ipro/Documents/code/code/xcode/gputest1/gputest1/simplekern.cl";
    float tgtX = 562721.0;
    float tgtY = 5117017.0;
    int skipVal = 1000;
    float minDist = 600.0;
    float maxDist = 4500.0;
    float gravity = 9.82;
    //TODO: Alter this based on the altitude
    float airDens = 1.225;
    //TODO: Allow setting of this based on weapon vars
    //Using Sreamlined body coefficient
    float dragCoef = 0.04; //Coef for sphere
    float pi = 3.1415926; // pi
    float calibre = 0.081;
    float fArea = pi*(pow((0.5*calibre), 2.0));
    float mortSigma = dragCoef*fArea*0.5*airDens;
    float muzzVel = 225.0;
    float mortMass = 4.2;
    float gForce = mortMass * gravity;
    float launchZ = 0.0;
    float tgtZ = 0.0;

    
    
    // For catching cl errors
    cl_int err;
    //get all platforms (drivers)
    std::vector<cl::Platform> platforms;
    std::vector<cl::Device> devices;
    std::vector<cl::Kernel> kernels;
    cl::Platform::get(&platforms);
    if(platforms.size()==0){
        std::cout<<" No platforms found. Check OpenCL installation!\n";
        exit(1);
    }
    std::cout << " All Platforms follow " << std::endl;
    for (auto plat : platforms) {
        std::cout << plat.getInfo<CL_PLATFORM_NAME>() << std::endl;
    }
    cl::Platform default_platform=platforms[0];
    std::cout << "Querying platform: "<<default_platform.getInfo<CL_PLATFORM_NAME>()<<"\n";
    
    //get default device of the default platform
    default_platform.getDevices(CL_DEVICE_TYPE_ALL, &devices);
    if(devices.size()==0){
        std::cout<<" No devices found. Check OpenCL installation!\n";
        exit(1);
    }
    std::cout << " All Devices follow " << std::endl;
    for (auto dev : devices) {
        std::cout << dev.getInfo<CL_DEVICE_NAME>() << std::endl;
    }
    
    
    // create platform
    cl::Platform::get(&platforms);
    platforms[0].getDevices(CL_DEVICE_TYPE_CPU, &devices);
    //Query device info for memory size
    std::cout << devices[0].getInfo<CL_DEVICE_LOCAL_MEM_SIZE>() << std::endl;
    
    //Change this if want to use GPU
    cl::Context context = cl::Context(devices);
    
    //Create Command queue
    cl::CommandQueue queue(context, devices[0]);
    
    // load opencl source
    std::ifstream cl_file(intersectKernel);
    std::string cl_string(std::istreambuf_iterator<char>(cl_file), (std::istreambuf_iterator<char>()));
    cl::Program::Sources source(1, std::make_pair(cl_string.c_str(), cl_string.length()+1));
    
    // create program
    cl::Program program(context, source);
    
    try {
        
        // compile opencl source
        program.build(devices);
        std::cout << "built kernel" << std::endl;
        
    }
    catch (cl::Error &err) {
        //Get the build log for the first device
        std::cerr << "Building failed, " << err.what() << "(" << err.err() << ")"
        << "\nRetrieving build log\n"
        << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0])
        << "\n";
        return -1;
        
    }
    
    std::cout << "Loading Kern func" << std::endl;
    // load named kernel from opencl source
    cl::Kernel kernel(program, "gdal_intersect");
    
    std::cout << "Building indata" << std::endl;
    
    //Open the DEM and load data into memory
    //GDAL Vars
    double        adfGeoTransform[6];
    //float rasterXSize = 0.0;
    //float rasterYSize = 0.0;
    GDALDataset  *poDataset;
    poDataset = Utils::openDem(demFName);
    
    //Get geotransform info ready
    poDataset->GetGeoTransform( adfGeoTransform );
    int rasterXSize = poDataset->GetRasterXSize();
    int rasterYSize = poDataset->GetRasterYSize();
    std::cout << "rasterSizeX: " << rasterXSize << std::endl;
    std::cout << "rasterSizeY: " << rasterYSize << std::endl;
    
    GDALRasterBand  *poBand;
    poBand = poDataset->GetRasterBand( 1 );
    int   nXSize = poBand->GetXSize();
    int   nYSize = poBand->GetYSize();
    
    std::vector<std::vector<double>> demSP = Utils::GDAL2VEC (poDataset);
    std::cout << "Size of DEM in memory Ref (kb): " << ((rasterXSize*rasterYSize)*sizeof(GDT_Float32))/1000 << std::endl;
    try {
    //Create a buffer object to this memory
        cl::Buffer inBuffDEMFull(context, CL_MEM_READ_ONLY | CL_MEM_USE_HOST_PTR, (rasterXSize*rasterYSize)*sizeof(GDT_Float32), &demSP, &err);
        
        //Testing parsing in array
        cl::Buffer outBuff(context, CL_MEM_WRITE_ONLY, (rasterXSize*rasterYSize)*sizeof(cl_int), NULL, NULL);
        //Make array for results - whole DEM
        int outArr[rasterYSize][rasterXSize];
        //Set Kernel Args
        err = kernel.setArg(0, inBuffDEMFull);
        err = kernel.setArg(1, sizeof(float), &tgtX);
        err = kernel.setArg(2, sizeof(float), &tgtY);
        err = kernel.setArg(3, sizeof(int), &rasterXSize);
        err = kernel.setArg(4, sizeof(int), &rasterYSize);
        err = kernel.setArg(5, sizeof(double), &adfGeoTransform[0]);
        err = kernel.setArg(6, sizeof(double), &adfGeoTransform[1]);
        err = kernel.setArg(7, sizeof(double), &adfGeoTransform[2]);
        err = kernel.setArg(8, sizeof(double), &adfGeoTransform[3]);
        err = kernel.setArg(9, sizeof(double), &adfGeoTransform[4]);
        err = kernel.setArg(10, sizeof(double), &adfGeoTransform[5]);
        err = kernel.setArg(11, sizeof(float), &minDist);
        err = kernel.setArg(12, sizeof(float), &maxDist);
        err = kernel.setArg(13, sizeof(float), &mortMass);
        err = kernel.setArg(14, sizeof(float), &muzzVel);
        err = kernel.setArg(15, sizeof(float), &mortSigma);
        err = kernel.setArg(16, sizeof(float), &gForce);
        err = kernel.setArg(17, sizeof(float), &launchZ);
        err = kernel.setArg(18, sizeof(float), &tgtZ);
        //err = kernel.setArg(16, sizeof(double), &maxDist);
        //err = kernel.setArg(5, sizeof(double)*6, &adfGeoTransform);
        err = kernel.setArg(19, outBuff);
        //Write the outputs
        queue.enqueueReadBuffer(outBuff, true, 0, sizeof(cl_int)*nXSize, outArr);
        if(err < 0) {
            perror("Couldn't create a kernel argument");
            exit(1);
        }
        // execute kernel
        //just does 1 dim - queue.enqueueTask(kernel);
        queue.enqueueNDRangeKernel(kernel, 0, nXSize);

        // wait for completion
        queue.finish();
    }
    catch (cl::Error &err) {
        //Get the build log for the first device
        std::cerr << "Building failed, " << err.what() << "(" << err.err() << ")"
        << "\nRetrieving build log\n"
        << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0])
        << "\n";
        return -1;

    }
    
    /*
    
    //Load all the DEM data into a 1d array
    //TODO: Store each row as a shared ptr - this will be resused and flattened
    std::vector<float> rowVec;
    //Using vector instead of CPLMalloc so memory is cleared by compiler...
    typedef std::vector<float> raster_data_t;
    raster_data_t scanline(nXSize);
    //Setup for TgtZ
    double pxX, pxY;
    Utils::coordtoPx2d(tgtX, tgtY, pxX, pxY, adfGeoTransform, rasterXSize, rasterYSize);
    //TODO: Improve this to accommodate where we dont have enough memory for the whole ptr...
    clock_t tt = clock();
    for (int row = 0; row < nYSize; row++)  {
        //Read one column from gdal
        poBand->RasterIO( GF_Read, 0, row, nXSize, 1, &scanline[0], nXSize, 1, GDT_Float32, 0, 0 );
        unsigned int taskSize = nXSize;
        //TgtZ - TODO Take this out of the loop!
        //Write some outputs
        try {
            cl::Buffer inBuffDEM(context, CL_MEM_READ_ONLY | CL_MEM_COPY_HOST_PTR, sizeof(float)*taskSize, &scanline, &err);
            cl::Buffer outBuff(context, CL_MEM_WRITE_ONLY, sizeof(cl_int)*taskSize, NULL, NULL);
            //Make array for results - whole DEM
            int outArr[taskSize];
            //Set Kernel Args
            err = kernel.setArg(0, inBuffDEM);
            err = kernel.setArg(1, sizeof(float), &tgtX);
            err = kernel.setArg(2, sizeof(float), &tgtY);
            err = kernel.setArg(3, sizeof(int), &rasterXSize);
            err = kernel.setArg(4, sizeof(int), &rasterYSize);
            err = kernel.setArg(5, sizeof(int), &row);
            err = kernel.setArg(6, sizeof(double), &adfGeoTransform[0]);
            err = kernel.setArg(7, sizeof(double), &adfGeoTransform[1]);
            err = kernel.setArg(8, sizeof(double), &adfGeoTransform[2]);
            err = kernel.setArg(9, sizeof(double), &adfGeoTransform[3]);
            err = kernel.setArg(10, sizeof(double), &adfGeoTransform[4]);
            err = kernel.setArg(11, sizeof(double), &adfGeoTransform[5]);
            err = kernel.setArg(12, sizeof(float), &minDist);
            err = kernel.setArg(13, sizeof(float), &maxDist);
            err = kernel.setArg(14, sizeof(float), &mortMass);
            err = kernel.setArg(15, sizeof(float), &muzzVel);
            err = kernel.setArg(16, sizeof(float), &mortSigma);
            err = kernel.setArg(17, sizeof(float), &gForce);
            err = kernel.setArg(18, sizeof(float), &launchZ);
            err = kernel.setArg(19, sizeof(float), &tgtZ);
            //err = kernel.setArg(16, sizeof(double), &maxDist);
            //err = kernel.setArg(5, sizeof(double)*6, &adfGeoTransform);
            err = kernel.setArg(20, outBuff);
            //Write the outputs
            queue.enqueueReadBuffer(outBuff, true, 0, sizeof(cl_int)*nXSize, outArr);
            if(err < 0) {
                perror("Couldn't create a kernel argument");
                exit(1);
            }
            // execute kernel
            //just does 1 dim - queue.enqueueTask(kernel);
            queue.enqueueNDRangeKernel(kernel, 0, nXSize);
            
            // wait for completion
            queue.finish();
        }
        catch (cl::Error &err) {
            //Get the build log for the first device
            std::cerr << "Building failed, " << err.what() << "(" << err.err() << ")"
            << "\nRetrieving build log\n"
            << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0])
            << "\n";
            return -1;
            
        }
        //Empty the rowVec for security
        rowVec.clear();
        scanline.clear();
    }
    */
    //Close gdal dataset
    GDALClose( (GDALDatasetH) poDataset );
    
    
    
    //Write some outputs
//    try {
//        
//    }
//    catch (cl::Error &err) {
//        //Get the build log for the first device
//        std::cerr << "Building failed, " << err.what() << "(" << err.err() << ")"
//        << "\nRetrieving build log\n"
//        << program.getBuildInfo<CL_PROGRAM_BUILD_LOG>(devices[0])
//        << "\n";
//        return -1;
//        
//    }
    
    //Timings
    //tt = clock() - tt;
    //std::cout << float(tt)/CLOCKS_PER_SEC << std::endl;
    
    std::cout << "Results follow: " << std::endl;
    //for (int i=0; i<taskSize; i++){
    //    std::cout << outArr[i] << std::endl;
    //}
    
    std::cout << "Done, skip count" << std::endl;
    
    
    return 0;
}
